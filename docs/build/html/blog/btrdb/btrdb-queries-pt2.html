
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Chunked Queries &#8212; NI4AI Blog 0.1 documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/blank.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/tree.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="16x16" href="../../_static/_static/tree.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/PingThings_logo_color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../workshops/index.html">
  Workshops
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../index.html">
  Blog Posts
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://btrdb.readthedocs.io/en/latest/">API Docs<i class="fas fa-external-link-alt"></i></a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://btrdb.readthedocs.io/en/latest/">PingThings<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PingThingsIO/ni4ai-notebooks" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://www.pingthings.io/" rel="noopener" target="_blank" title="PingThings">
            <span><i class="fa"></i></span>
            <label class="sr-only">PingThings</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Chunked Queries
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tree-traversal-queries-in-btrdb">
   Tree Traversal Queries in BTrDB
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#breadth-first-example">
     Breadth-First Example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <p>In Part I we introduced the tree data structure and discussed the two main algorithms for traversing them: depth-first and breadth-first. It is highly recommended that you review that post if these concepts are new to you, as Part II will build on them with more complicated examples using <a class="reference external" href="http://btrdb.io/">the Berkeley Tree Database (BTrDB)</a>.</p>
<p>In this post we will review three multi-query approaches for memory safety. First, we will explore chunked queries that allow us to scan across the database, loading fixed size chunks of memory at a time. Then, using this as a building block, we will explore tree based queries that execute at higher levels of time granularity (higher in the tree), only querying at lower levels when needed.</p>
<section id="chunked-queries">
<h1>Chunked Queries<a class="headerlink" href="#chunked-queries" title="Permalink to this headline">¶</a></h1>
<p>Consider the problem where you would like to conduct an analysis over a month of data. At a 120 Hz sample rate, this query will collect 313,632,000 points of data, which at roughly 16 bytes per point is a total query size of 5.02 GB. Although most modern laptops can easily hold this in memory at a given time, consider that many computations may double or triple the memory requirements to produce a result, and if the computation takes a long time, holding a database cursor open for that long may lead to in-process failures which require restarting the whole computation.</p>
<p>One solution is to query only a week or a day at a time, yielding the materialized data to the computation before issuing the next query. This is a fairly simple function to write in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">btrdb.utils.timez</span> <span class="kn">import</span> <span class="n">ns_delta</span><span class="p">,</span> <span class="n">to_nanoseconds</span>

<span class="k">def</span> <span class="nf">chunked_values</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">chunk</span><span class="o">=</span><span class="n">ns_delta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">version</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># Convert start and end to nanoseconds to make range math easier.</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">to_nanoseconds</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">to_nanoseconds</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="c1"># Range over the chunk start times using the chunk step</span>
    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">chunk</span><span class="p">):</span>
        <span class="c1"># Perform the database query and yield it</span>
        <span class="k">yield</span> <span class="n">stream</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="n">chunk</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>

<span class="c1"># Use the function to issue 4 queries</span>
<span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;2020-01-01T00:00:00.000Z&quot;</span>
<span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;2020-01-31T00:00:00.000Z&quot;</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">chunked_values</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ns_delta</span><span class="p">(</span><span class="n">weeks</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="c1"># use point</span>
</pre></div>
</div>
<p>Similar functions can be written for <code class="docutils literal notranslate"><span class="pre">windows</span></code> and <code class="docutils literal notranslate"><span class="pre">aligned_windows</span></code> as well.</p>
<p>There is a trade-off to using this function, although you are using a quarter of the memory than you would have by materializing an entire month of data, you do so at the increased latency of issuing 3 more queries to the database. Balance between the amount of data loaded per query and the number of queries issued is very important; when computing across a month of data you would only want to query no less than a few days at a time. Using this basic building block of issuing multiple queries across specific ranges of time, we will explore more complex queries that directly leverage the Berkeley Tree to only access data required for the computation, pruning away unnecessary queries.</p>
</section>
<section id="tree-traversal-queries-in-btrdb">
<h1>Tree Traversal Queries in BTrDB<a class="headerlink" href="#tree-traversal-queries-in-btrdb" title="Permalink to this headline">¶</a></h1>
<p>BTrDB is a tree data structure that is not dissimilar from the tree structure saw in Part I. It’s root and interior nodes are composed of <code class="docutils literal notranslate"><span class="pre">StatPoints</span></code> that describe a window of time with statistical aggregates and it’s leaf nodes can be thought of as individual points. Although you cannot directly query the children of a stat point in the tree, a similar effect is possible using <code class="docutils literal notranslate"><span class="pre">windows</span></code> and <code class="docutils literal notranslate"><span class="pre">aligned_windows</span></code> queries where the <code class="docutils literal notranslate"><span class="pre">depth</span></code> and <code class="docutils literal notranslate"><span class="pre">pointwidth</span></code> arguments specify the level of the tree that is being traversed and the time range specified by the query can be directly fetched from the parent node (which is also true for <code class="docutils literal notranslate"><span class="pre">values</span></code> queries).</p>
<p>To demonstrate this, let’s take a toy example where we want to find the <em>time of the minimum value</em> in a stream. We will explore both depth-first and breadth-first traversal strategies to see which is more efficient. To start, note that it is very fast to get the <em>minimum value</em> of a stream:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_minimum_value</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># Get all of the stat points at the highest level of the tree as possible</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">aligned_windows</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MINIMUM_TIME</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MAXIMUM_TIME</span><span class="p">,</span> <span class="n">pointwidth</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span>
    <span class="p">)</span>

    <span class="c1"># Unless you have decades of data, this will likely only be one stat point</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">window</span><span class="o">.</span><span class="n">min</span> <span class="k">for</span> <span class="n">window</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>This function collects the root node of the tree by performing an <code class="docutils literal notranslate"><span class="pre">aligned_windows</span></code> query at <code class="docutils literal notranslate"><span class="pre">pointwidth=60</span></code>, which should return only one stat point unless you have decades of data stored in the database (for completeness, we still take the minimum of all returned windows if more than one is returned). Because a stat point is returned, we can directly fetch the minimum value from the point. However, what if we wanted to know <em>when</em> that minimum value occurred?</p>
<p>Here is an example of how to answer that question with a depth-first approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">btrdb.utils.general</span> <span class="kn">import</span> <span class="n">pointwidth</span>

<span class="k">def</span> <span class="nf">find_points_dfs</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">start</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MINIMUM_TIME</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MAXIMUM_TIME</span><span class="p">,</span>
    <span class="n">pw</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
    <span class="c1"># Ensure pw is a pointwidth object</span>
    <span class="n">pw</span> <span class="o">=</span> <span class="n">pointwidth</span><span class="p">(</span><span class="n">pw</span><span class="p">)</span>

    <span class="c1"># Begin by collecting all stat points at the specified pointwidth</span>
    <span class="c1"># Note that zip creates a list of windows and versions and we ignore the versions</span>
    <span class="n">windows</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">stream</span><span class="o">.</span><span class="n">aligned_windows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>

    <span class="c1"># Traversing from left to right from the windows</span>
    <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
        <span class="c1"># Check to see if the value is in the window</span>
        <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">min</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="c1"># Get the time range of the current window</span>
            <span class="n">wstart</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">time</span>
            <span class="n">wend</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">pw</span><span class="o">.</span><span class="n">nanoseconds</span>

            <span class="k">if</span> <span class="n">pw</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
                <span class="c1"># If we are at a window length of a second, use values</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">stream</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">wstart</span><span class="p">,</span> <span class="n">wend</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise, traverse the stat point children of this node</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">find_points_dfs</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">wstart</span><span class="p">,</span> <span class="n">wend</span><span class="p">,</span> <span class="n">pw</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>

            <span class="c1"># Yield all points to the calling function</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">point</span>

<span class="c1"># Find the time of of the smallest value in the stream</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">get_minimum_value</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">find_points_dfs</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">find_points_dfs()</span></code> function starts by performing an <code class="docutils literal notranslate"><span class="pre">aligned_windows</span></code> query to retrieve <code class="docutils literal notranslate"><span class="pre">StatPoints</span></code>, which are aggregated points from BTrDB at the provided pointwidth. It then iterates through each retrieved window and checks to see if it contains the desired minimum value. If it does, it either conducts another <code class="docutils literal notranslate"><span class="pre">aligned_windows()</span></code> query to move down one level in the tree (<code class="docutils literal notranslate"><span class="pre">pw</span></code> - 1) and recursively calls <code class="docutils literal notranslate"><span class="pre">find_points()</span></code>, or performs a <code class="docutils literal notranslate"><span class="pre">values()</span></code> query to return raw values which are iterated through in search of the minimum value. It is important to note that it is not necessary to traverse one pointwidth at a time, and in fact it may be a better strategy to skip multiple levels to reduce the latency by minimizing the number of calls to the database. This idea relates back to the trade-off between number of queries and amount of data returned from each query that we discussed earlier in this post. Once raw values are returned from the <code class="docutils literal notranslate"><span class="pre">values()</span></code> query, the function iterates through them and yields those that match the minimum value.</p>
<section id="breadth-first-example">
<h2>Breadth-First Example<a class="headerlink" href="#breadth-first-example" title="Permalink to this headline">¶</a></h2>
<p>To compare the two approaches, we can look at an example of how we would solve the same problem of finding the time of our minimum value using a breadth-first approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c1">#Instantiating our namedtuple that will contain our aggregated windows</span>
<span class="n">Window</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Window&quot;</span><span class="p">,</span> <span class="s2">&quot;time,min,max,pw&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">query_windows</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pw</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of named tuples that contain agggregated windows to be added to our list of windows to traverse</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pointwidth</span><span class="p">(</span><span class="n">pw</span><span class="p">)</span><span class="o">.</span><span class="n">nanoseconds</span>

    <span class="n">points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">stream</span><span class="o">.</span><span class="n">aligned_windows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pointwidth</span><span class="p">(</span><span class="n">pw</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">version</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">[</span>
        <span class="n">Window</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">pointwidth</span><span class="p">(</span><span class="n">pw</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">find_points_bfs</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">start</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MINIMUM_TIME</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="n">btrdb</span><span class="o">.</span><span class="n">MAXIMUM_TIME</span><span class="p">,</span>
    <span class="n">pw</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
    <span class="n">min_depth</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
    <span class="c1"># Set up the bfs recursive call</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">query_windows</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">_find_points_bfs_recursive</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">min_depth</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">point</span>

<span class="k">def</span> <span class="nf">_find_points_bfs_recursive</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">windows</span><span class="p">,</span>
    <span class="n">min_depth</span><span class="p">,</span>
    <span class="n">version</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function implements recursive breadth-first traversal to find all points with the matching value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Stopping condition 1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">Window</span><span class="p">):</span>

        <span class="c1"># Check if the value we&#39;re looking for is in the window</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">min</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">current</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>

            <span class="c1"># Append the child nodes to the traversal windows</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">pw</span> <span class="o">&gt;</span> <span class="n">min_depth</span><span class="p">:</span>
                <span class="n">windows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">query_windows</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">pw</span><span class="o">=</span><span class="n">current</span><span class="o">.</span><span class="n">pw</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Append raw points to the windows if we&#39;ve reached the minimum pontwidth</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">stream</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">time</span><span class="o">+</span><span class="n">current</span><span class="o">.</span><span class="n">pw</span><span class="o">.</span><span class="n">nanoseconds</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>
                <span class="n">windows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Recurse into the children, omitting current</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">_find_points_bfs_recursive</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">windows</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">min_depth</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">point</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Stopping condition 2: every point from hereafter is going to be a raw point</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">point</span>

<span class="c1"># Using the function from the last example to get the minimum value in the stream</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">get_minimum_value</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">find_points_bfs</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
</pre></div>
</div>
<p>There are a couple of important differences between this function and the depth-first approach. The first is that once it identifies a window that contains the desired value, it issues another <code class="docutils literal notranslate"><span class="pre">aligned_windows()</span></code> query and adds the resulting windows to the <em>end</em> of the list of windows to traverse before recursively calling <code class="docutils literal notranslate"><span class="pre">find_points_bfs()</span></code>, rather than immediately jumping down a level in the tree, as you would with depth-first. The second difference is that with this approach it is important to track the pointwidth of each window as the function progresses so we know when to issue a <code class="docutils literal notranslate"><span class="pre">values()</span></code> query and examine raw values once we reach our <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> (poinwidth of 30 in this case). This is done by storing each window as a tuple that contains the statpoint and the pointwidth that was used to retreive that statpoint. The end of the function looks similar though; once it receives raw values it iterates through them and yields those that match our criteria.</p>
</section>
</section>
<section id="conclusion">
<h1>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h1>
<p>The question of which approach is better largely depends on the problem that you are trying to solve. Depth-first is generally preferred when you are searching for a single value, as we were in our toy example, while breadth-first is more suitable for tasks such as finding all values below a certain threshold, or within a certain range of values.</p>
<p>The key concept to understand is that both <code class="docutils literal notranslate"><span class="pre">find_points_dfs()</span></code> and <code class="docutils literal notranslate"><span class="pre">find_points_bfs()</span></code> only traverse to child nodes when their parents contain the target minimum value, while ignoring those that do not. This allows us to prune away unnecessary data and conduct memory efficient and better performing queries.</p>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, PingThings.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>